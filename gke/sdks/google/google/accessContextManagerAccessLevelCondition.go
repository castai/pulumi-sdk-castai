// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package google

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-terraform-provider/sdks/go/google/v6/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AccessContextManagerAccessLevelCondition struct {
	pulumi.CustomResourceState

	AccessContextManagerAccessLevelConditionId pulumi.StringOutput `pulumi:"accessContextManagerAccessLevelConditionId"`
	// The name of the Access Level to add this condition to.
	AccessLevel pulumi.StringOutput `pulumi:"accessLevel"`
	// The name of the Access Policy this resource belongs to.
	AccessPolicyId pulumi.StringOutput `pulumi:"accessPolicyId"`
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are
	// allowed.
	DevicePolicy AccessContextManagerAccessLevelConditionDevicePolicyPtrOutput `pulumi:"devicePolicy"`
	// A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the
	// specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered
	// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is
	// accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order
	// for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks pulumi.StringArrayOutput `pulumi:"ipSubnetworks"`
	// An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating
	// the request must be a part of one of the provided members. If not specified, a request may come from any user (logged
	// in/not logged in, not present in any groups, etc.). Formats: 'user:{emailid}', 'serviceAccount:{emailid}'
	Members pulumi.StringArrayOutput `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be
	// false for the Condition overall to be satisfied. Defaults to false.
	Negate pulumi.BoolPtrOutput `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
	Regions pulumi.StringArrayOutput `pulumi:"regions"`
	// A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be granted for the Condition to be true. Format:
	// accessPolicies/{policy_id}/accessLevels/{short_name}
	RequiredAccessLevels pulumi.StringArrayOutput                                  `pulumi:"requiredAccessLevels"`
	Timeouts             AccessContextManagerAccessLevelConditionTimeoutsPtrOutput `pulumi:"timeouts"`
	// The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together
	// with 'ip_subnetworks'.
	VpcNetworkSources AccessContextManagerAccessLevelConditionVpcNetworkSourceArrayOutput `pulumi:"vpcNetworkSources"`
}

// NewAccessContextManagerAccessLevelCondition registers a new resource with the given unique name, arguments, and options.
func NewAccessContextManagerAccessLevelCondition(ctx *pulumi.Context,
	name string, args *AccessContextManagerAccessLevelConditionArgs, opts ...pulumi.ResourceOption) (*AccessContextManagerAccessLevelCondition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccessLevel == nil {
		return nil, errors.New("invalid value for required argument 'AccessLevel'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	ref, err := internal.PkgGetPackageRef(ctx)
	if err != nil {
		return nil, err
	}
	var resource AccessContextManagerAccessLevelCondition
	err = ctx.RegisterPackageResource("google:index/accessContextManagerAccessLevelCondition:AccessContextManagerAccessLevelCondition", name, args, &resource, ref, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccessContextManagerAccessLevelCondition gets an existing AccessContextManagerAccessLevelCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccessContextManagerAccessLevelCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccessContextManagerAccessLevelConditionState, opts ...pulumi.ResourceOption) (*AccessContextManagerAccessLevelCondition, error) {
	var resource AccessContextManagerAccessLevelCondition
	ref, err := internal.PkgGetPackageRef(ctx)
	if err != nil {
		return nil, err
	}
	err = ctx.ReadPackageResource("google:index/accessContextManagerAccessLevelCondition:AccessContextManagerAccessLevelCondition", name, id, state, &resource, ref, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccessContextManagerAccessLevelCondition resources.
type accessContextManagerAccessLevelConditionState struct {
	AccessContextManagerAccessLevelConditionId *string `pulumi:"accessContextManagerAccessLevelConditionId"`
	// The name of the Access Level to add this condition to.
	AccessLevel *string `pulumi:"accessLevel"`
	// The name of the Access Policy this resource belongs to.
	AccessPolicyId *string `pulumi:"accessPolicyId"`
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are
	// allowed.
	DevicePolicy *AccessContextManagerAccessLevelConditionDevicePolicy `pulumi:"devicePolicy"`
	// A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the
	// specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered
	// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is
	// accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order
	// for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks []string `pulumi:"ipSubnetworks"`
	// An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating
	// the request must be a part of one of the provided members. If not specified, a request may come from any user (logged
	// in/not logged in, not present in any groups, etc.). Formats: 'user:{emailid}', 'serviceAccount:{emailid}'
	Members []string `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be
	// false for the Condition overall to be satisfied. Defaults to false.
	Negate *bool `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
	Regions []string `pulumi:"regions"`
	// A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be granted for the Condition to be true. Format:
	// accessPolicies/{policy_id}/accessLevels/{short_name}
	RequiredAccessLevels []string                                          `pulumi:"requiredAccessLevels"`
	Timeouts             *AccessContextManagerAccessLevelConditionTimeouts `pulumi:"timeouts"`
	// The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together
	// with 'ip_subnetworks'.
	VpcNetworkSources []AccessContextManagerAccessLevelConditionVpcNetworkSource `pulumi:"vpcNetworkSources"`
}

type AccessContextManagerAccessLevelConditionState struct {
	AccessContextManagerAccessLevelConditionId pulumi.StringPtrInput
	// The name of the Access Level to add this condition to.
	AccessLevel pulumi.StringPtrInput
	// The name of the Access Policy this resource belongs to.
	AccessPolicyId pulumi.StringPtrInput
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are
	// allowed.
	DevicePolicy AccessContextManagerAccessLevelConditionDevicePolicyPtrInput
	// A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the
	// specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered
	// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is
	// accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order
	// for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks pulumi.StringArrayInput
	// An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating
	// the request must be a part of one of the provided members. If not specified, a request may come from any user (logged
	// in/not logged in, not present in any groups, etc.). Formats: 'user:{emailid}', 'serviceAccount:{emailid}'
	Members pulumi.StringArrayInput
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be
	// false for the Condition overall to be satisfied. Defaults to false.
	Negate pulumi.BoolPtrInput
	// The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
	Regions pulumi.StringArrayInput
	// A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be granted for the Condition to be true. Format:
	// accessPolicies/{policy_id}/accessLevels/{short_name}
	RequiredAccessLevels pulumi.StringArrayInput
	Timeouts             AccessContextManagerAccessLevelConditionTimeoutsPtrInput
	// The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together
	// with 'ip_subnetworks'.
	VpcNetworkSources AccessContextManagerAccessLevelConditionVpcNetworkSourceArrayInput
}

func (AccessContextManagerAccessLevelConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*accessContextManagerAccessLevelConditionState)(nil)).Elem()
}

type accessContextManagerAccessLevelConditionArgs struct {
	AccessContextManagerAccessLevelConditionId *string `pulumi:"accessContextManagerAccessLevelConditionId"`
	// The name of the Access Level to add this condition to.
	AccessLevel string `pulumi:"accessLevel"`
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are
	// allowed.
	DevicePolicy *AccessContextManagerAccessLevelConditionDevicePolicy `pulumi:"devicePolicy"`
	// A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the
	// specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered
	// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is
	// accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order
	// for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks []string `pulumi:"ipSubnetworks"`
	// An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating
	// the request must be a part of one of the provided members. If not specified, a request may come from any user (logged
	// in/not logged in, not present in any groups, etc.). Formats: 'user:{emailid}', 'serviceAccount:{emailid}'
	Members []string `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be
	// false for the Condition overall to be satisfied. Defaults to false.
	Negate *bool `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
	Regions []string `pulumi:"regions"`
	// A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be granted for the Condition to be true. Format:
	// accessPolicies/{policy_id}/accessLevels/{short_name}
	RequiredAccessLevels []string                                          `pulumi:"requiredAccessLevels"`
	Timeouts             *AccessContextManagerAccessLevelConditionTimeouts `pulumi:"timeouts"`
	// The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together
	// with 'ip_subnetworks'.
	VpcNetworkSources []AccessContextManagerAccessLevelConditionVpcNetworkSource `pulumi:"vpcNetworkSources"`
}

// The set of arguments for constructing a AccessContextManagerAccessLevelCondition resource.
type AccessContextManagerAccessLevelConditionArgs struct {
	AccessContextManagerAccessLevelConditionId pulumi.StringPtrInput
	// The name of the Access Level to add this condition to.
	AccessLevel pulumi.StringInput
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are
	// allowed.
	DevicePolicy AccessContextManagerAccessLevelConditionDevicePolicyPtrInput
	// A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the
	// specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered
	// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is
	// accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order
	// for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks pulumi.StringArrayInput
	// An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating
	// the request must be a part of one of the provided members. If not specified, a request may come from any user (logged
	// in/not logged in, not present in any groups, etc.). Formats: 'user:{emailid}', 'serviceAccount:{emailid}'
	Members pulumi.StringArrayInput
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be
	// false for the Condition overall to be satisfied. Defaults to false.
	Negate pulumi.BoolPtrInput
	// The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
	Regions pulumi.StringArrayInput
	// A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be granted for the Condition to be true. Format:
	// accessPolicies/{policy_id}/accessLevels/{short_name}
	RequiredAccessLevels pulumi.StringArrayInput
	Timeouts             AccessContextManagerAccessLevelConditionTimeoutsPtrInput
	// The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together
	// with 'ip_subnetworks'.
	VpcNetworkSources AccessContextManagerAccessLevelConditionVpcNetworkSourceArrayInput
}

func (AccessContextManagerAccessLevelConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accessContextManagerAccessLevelConditionArgs)(nil)).Elem()
}

type AccessContextManagerAccessLevelConditionInput interface {
	pulumi.Input

	ToAccessContextManagerAccessLevelConditionOutput() AccessContextManagerAccessLevelConditionOutput
	ToAccessContextManagerAccessLevelConditionOutputWithContext(ctx context.Context) AccessContextManagerAccessLevelConditionOutput
}

func (*AccessContextManagerAccessLevelCondition) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessContextManagerAccessLevelCondition)(nil)).Elem()
}

func (i *AccessContextManagerAccessLevelCondition) ToAccessContextManagerAccessLevelConditionOutput() AccessContextManagerAccessLevelConditionOutput {
	return i.ToAccessContextManagerAccessLevelConditionOutputWithContext(context.Background())
}

func (i *AccessContextManagerAccessLevelCondition) ToAccessContextManagerAccessLevelConditionOutputWithContext(ctx context.Context) AccessContextManagerAccessLevelConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessContextManagerAccessLevelConditionOutput)
}

type AccessContextManagerAccessLevelConditionOutput struct{ *pulumi.OutputState }

func (AccessContextManagerAccessLevelConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessContextManagerAccessLevelCondition)(nil)).Elem()
}

func (o AccessContextManagerAccessLevelConditionOutput) ToAccessContextManagerAccessLevelConditionOutput() AccessContextManagerAccessLevelConditionOutput {
	return o
}

func (o AccessContextManagerAccessLevelConditionOutput) ToAccessContextManagerAccessLevelConditionOutputWithContext(ctx context.Context) AccessContextManagerAccessLevelConditionOutput {
	return o
}

func (o AccessContextManagerAccessLevelConditionOutput) AccessContextManagerAccessLevelConditionId() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringOutput {
		return v.AccessContextManagerAccessLevelConditionId
	}).(pulumi.StringOutput)
}

// The name of the Access Level to add this condition to.
func (o AccessContextManagerAccessLevelConditionOutput) AccessLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringOutput { return v.AccessLevel }).(pulumi.StringOutput)
}

// The name of the Access Policy this resource belongs to.
func (o AccessContextManagerAccessLevelConditionOutput) AccessPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringOutput { return v.AccessPolicyId }).(pulumi.StringOutput)
}

// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are
// allowed.
func (o AccessContextManagerAccessLevelConditionOutput) DevicePolicy() AccessContextManagerAccessLevelConditionDevicePolicyPtrOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) AccessContextManagerAccessLevelConditionDevicePolicyPtrOutput {
		return v.DevicePolicy
	}).(AccessContextManagerAccessLevelConditionDevicePolicyPtrOutput)
}

// A list of CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the
// specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered
// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is
// accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order
// for this Condition to be true. If empty, all IP addresses are allowed.
func (o AccessContextManagerAccessLevelConditionOutput) IpSubnetworks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringArrayOutput { return v.IpSubnetworks }).(pulumi.StringArrayOutput)
}

// An allowed list of members (users, service accounts). Using groups is not supported yet. The signed-in user originating
// the request must be a part of one of the provided members. If not specified, a request may come from any user (logged
// in/not logged in, not present in any groups, etc.). Formats: 'user:{emailid}', 'serviceAccount:{emailid}'
func (o AccessContextManagerAccessLevelConditionOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringArrayOutput { return v.Members }).(pulumi.StringArrayOutput)
}

// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be
// false for the Condition overall to be satisfied. Defaults to false.
func (o AccessContextManagerAccessLevelConditionOutput) Negate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.BoolPtrOutput { return v.Negate }).(pulumi.BoolPtrOutput)
}

// The request must originate from one of the provided countries/regions. Format: A valid ISO 3166-1 alpha-2 code.
func (o AccessContextManagerAccessLevelConditionOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringArrayOutput { return v.Regions }).(pulumi.StringArrayOutput)
}

// A list of other access levels defined in the same Policy, referenced by resource name. Referencing an AccessLevel which
// does not exist is an error. All access levels listed must be granted for the Condition to be true. Format:
// accessPolicies/{policy_id}/accessLevels/{short_name}
func (o AccessContextManagerAccessLevelConditionOutput) RequiredAccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) pulumi.StringArrayOutput {
		return v.RequiredAccessLevels
	}).(pulumi.StringArrayOutput)
}

func (o AccessContextManagerAccessLevelConditionOutput) Timeouts() AccessContextManagerAccessLevelConditionTimeoutsPtrOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) AccessContextManagerAccessLevelConditionTimeoutsPtrOutput {
		return v.Timeouts
	}).(AccessContextManagerAccessLevelConditionTimeoutsPtrOutput)
}

// The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together
// with 'ip_subnetworks'.
func (o AccessContextManagerAccessLevelConditionOutput) VpcNetworkSources() AccessContextManagerAccessLevelConditionVpcNetworkSourceArrayOutput {
	return o.ApplyT(func(v *AccessContextManagerAccessLevelCondition) AccessContextManagerAccessLevelConditionVpcNetworkSourceArrayOutput {
		return v.VpcNetworkSources
	}).(AccessContextManagerAccessLevelConditionVpcNetworkSourceArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccessContextManagerAccessLevelConditionInput)(nil)).Elem(), &AccessContextManagerAccessLevelCondition{})
	pulumi.RegisterOutputType(AccessContextManagerAccessLevelConditionOutput{})
}
