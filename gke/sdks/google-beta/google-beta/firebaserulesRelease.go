// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package googlebeta

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-terraform-provider/sdks/go/google-beta/v6/google-beta/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type FirebaserulesRelease struct {
	pulumi.CustomResourceState

	// Output only. Time the release was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// Disable the release to keep it from being served. The response code of NOT_FOUND will be given for executables generated
	// from this Release.
	Disabled               pulumi.BoolOutput   `pulumi:"disabled"`
	FirebaserulesReleaseId pulumi.StringOutput `pulumi:"firebaserulesReleaseId"`
	// Format: `projects/{project_id}/releases/{release_id}`\Firestore Rules Releases will **always** have the name
	// 'cloud.firestore'
	Name pulumi.StringOutput `pulumi:"name"`
	// The project for the resource
	Project pulumi.StringOutput `pulumi:"project"`
	// Name of the `Ruleset` referred to by this `Release`. The `Ruleset` must exist for the `Release` to be created.
	RulesetName pulumi.StringOutput                   `pulumi:"rulesetName"`
	Timeouts    FirebaserulesReleaseTimeoutsPtrOutput `pulumi:"timeouts"`
	// Output only. Time the release was updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewFirebaserulesRelease registers a new resource with the given unique name, arguments, and options.
func NewFirebaserulesRelease(ctx *pulumi.Context,
	name string, args *FirebaserulesReleaseArgs, opts ...pulumi.ResourceOption) (*FirebaserulesRelease, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RulesetName == nil {
		return nil, errors.New("invalid value for required argument 'RulesetName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	ref, err := internal.PkgGetPackageRef(ctx)
	if err != nil {
		return nil, err
	}
	var resource FirebaserulesRelease
	err = ctx.RegisterPackageResource("google-beta:index/firebaserulesRelease:FirebaserulesRelease", name, args, &resource, ref, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirebaserulesRelease gets an existing FirebaserulesRelease resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirebaserulesRelease(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirebaserulesReleaseState, opts ...pulumi.ResourceOption) (*FirebaserulesRelease, error) {
	var resource FirebaserulesRelease
	ref, err := internal.PkgGetPackageRef(ctx)
	if err != nil {
		return nil, err
	}
	err = ctx.ReadPackageResource("google-beta:index/firebaserulesRelease:FirebaserulesRelease", name, id, state, &resource, ref, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FirebaserulesRelease resources.
type firebaserulesReleaseState struct {
	// Output only. Time the release was created.
	CreateTime *string `pulumi:"createTime"`
	// Disable the release to keep it from being served. The response code of NOT_FOUND will be given for executables generated
	// from this Release.
	Disabled               *bool   `pulumi:"disabled"`
	FirebaserulesReleaseId *string `pulumi:"firebaserulesReleaseId"`
	// Format: `projects/{project_id}/releases/{release_id}`\Firestore Rules Releases will **always** have the name
	// 'cloud.firestore'
	Name *string `pulumi:"name"`
	// The project for the resource
	Project *string `pulumi:"project"`
	// Name of the `Ruleset` referred to by this `Release`. The `Ruleset` must exist for the `Release` to be created.
	RulesetName *string                       `pulumi:"rulesetName"`
	Timeouts    *FirebaserulesReleaseTimeouts `pulumi:"timeouts"`
	// Output only. Time the release was updated.
	UpdateTime *string `pulumi:"updateTime"`
}

type FirebaserulesReleaseState struct {
	// Output only. Time the release was created.
	CreateTime pulumi.StringPtrInput
	// Disable the release to keep it from being served. The response code of NOT_FOUND will be given for executables generated
	// from this Release.
	Disabled               pulumi.BoolPtrInput
	FirebaserulesReleaseId pulumi.StringPtrInput
	// Format: `projects/{project_id}/releases/{release_id}`\Firestore Rules Releases will **always** have the name
	// 'cloud.firestore'
	Name pulumi.StringPtrInput
	// The project for the resource
	Project pulumi.StringPtrInput
	// Name of the `Ruleset` referred to by this `Release`. The `Ruleset` must exist for the `Release` to be created.
	RulesetName pulumi.StringPtrInput
	Timeouts    FirebaserulesReleaseTimeoutsPtrInput
	// Output only. Time the release was updated.
	UpdateTime pulumi.StringPtrInput
}

func (FirebaserulesReleaseState) ElementType() reflect.Type {
	return reflect.TypeOf((*firebaserulesReleaseState)(nil)).Elem()
}

type firebaserulesReleaseArgs struct {
	FirebaserulesReleaseId *string `pulumi:"firebaserulesReleaseId"`
	// Format: `projects/{project_id}/releases/{release_id}`\Firestore Rules Releases will **always** have the name
	// 'cloud.firestore'
	Name *string `pulumi:"name"`
	// The project for the resource
	Project *string `pulumi:"project"`
	// Name of the `Ruleset` referred to by this `Release`. The `Ruleset` must exist for the `Release` to be created.
	RulesetName string                        `pulumi:"rulesetName"`
	Timeouts    *FirebaserulesReleaseTimeouts `pulumi:"timeouts"`
}

// The set of arguments for constructing a FirebaserulesRelease resource.
type FirebaserulesReleaseArgs struct {
	FirebaserulesReleaseId pulumi.StringPtrInput
	// Format: `projects/{project_id}/releases/{release_id}`\Firestore Rules Releases will **always** have the name
	// 'cloud.firestore'
	Name pulumi.StringPtrInput
	// The project for the resource
	Project pulumi.StringPtrInput
	// Name of the `Ruleset` referred to by this `Release`. The `Ruleset` must exist for the `Release` to be created.
	RulesetName pulumi.StringInput
	Timeouts    FirebaserulesReleaseTimeoutsPtrInput
}

func (FirebaserulesReleaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firebaserulesReleaseArgs)(nil)).Elem()
}

type FirebaserulesReleaseInput interface {
	pulumi.Input

	ToFirebaserulesReleaseOutput() FirebaserulesReleaseOutput
	ToFirebaserulesReleaseOutputWithContext(ctx context.Context) FirebaserulesReleaseOutput
}

func (*FirebaserulesRelease) ElementType() reflect.Type {
	return reflect.TypeOf((**FirebaserulesRelease)(nil)).Elem()
}

func (i *FirebaserulesRelease) ToFirebaserulesReleaseOutput() FirebaserulesReleaseOutput {
	return i.ToFirebaserulesReleaseOutputWithContext(context.Background())
}

func (i *FirebaserulesRelease) ToFirebaserulesReleaseOutputWithContext(ctx context.Context) FirebaserulesReleaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirebaserulesReleaseOutput)
}

type FirebaserulesReleaseOutput struct{ *pulumi.OutputState }

func (FirebaserulesReleaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirebaserulesRelease)(nil)).Elem()
}

func (o FirebaserulesReleaseOutput) ToFirebaserulesReleaseOutput() FirebaserulesReleaseOutput {
	return o
}

func (o FirebaserulesReleaseOutput) ToFirebaserulesReleaseOutputWithContext(ctx context.Context) FirebaserulesReleaseOutput {
	return o
}

// Output only. Time the release was created.
func (o FirebaserulesReleaseOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// Disable the release to keep it from being served. The response code of NOT_FOUND will be given for executables generated
// from this Release.
func (o FirebaserulesReleaseOutput) Disabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.BoolOutput { return v.Disabled }).(pulumi.BoolOutput)
}

func (o FirebaserulesReleaseOutput) FirebaserulesReleaseId() pulumi.StringOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.StringOutput { return v.FirebaserulesReleaseId }).(pulumi.StringOutput)
}

// Format: `projects/{project_id}/releases/{release_id}`\Firestore Rules Releases will **always** have the name
// 'cloud.firestore'
func (o FirebaserulesReleaseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The project for the resource
func (o FirebaserulesReleaseOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Name of the `Ruleset` referred to by this `Release`. The `Ruleset` must exist for the `Release` to be created.
func (o FirebaserulesReleaseOutput) RulesetName() pulumi.StringOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.StringOutput { return v.RulesetName }).(pulumi.StringOutput)
}

func (o FirebaserulesReleaseOutput) Timeouts() FirebaserulesReleaseTimeoutsPtrOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) FirebaserulesReleaseTimeoutsPtrOutput { return v.Timeouts }).(FirebaserulesReleaseTimeoutsPtrOutput)
}

// Output only. Time the release was updated.
func (o FirebaserulesReleaseOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *FirebaserulesRelease) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirebaserulesReleaseInput)(nil)).Elem(), &FirebaserulesRelease{})
	pulumi.RegisterOutputType(FirebaserulesReleaseOutput{})
}
